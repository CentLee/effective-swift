# Item 51. 메서드 시그니처를 신중히 설계하라

## API 설계 요령들

### 메서드 이름을 신중히 짓자.

[Swift API Design Guide](https://swift.org/documentation/api-design-guidelines/)는 모든 Swift Style Guide의 근간이 되는 가이드입니다. Swift API Design Guide를 참고하고 메서드 이름을 짓습니다. 다음은 가이드 중에 메서드, 매개변수 네이밍에 대한 일부 규칙입니다. 

> 메서드 

* 

> 매개변수 

* 

더 자세한 내용은 Swift API Design Guide를 참고 바랍니다. 

### 편의 메서드를 너무 많이 만들지 말자.

편의 메서드를 너무 많이 만들지 맙시다. 모든 메서드는 각각 자신의 소임을 다해야 합니다. 메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵습니다. 인터페이스도 마찬가지입니다. 클래스나 인터페이스는 자신의 각 기능을 완벽히 수행하는 메서드로 제공해야 합니다. 아주 자주 쓰일 경우에만 별도의 약칭 메서드를 두기 바랍니다. **확신이 서지 않으면 만들지 맙시다.**

특히 API의 프로퍼티로 배열이 있어서 배열의 특정 값을 순회하며 찾는 경우, 해당 값을 반환하는 메소드를 만들지 말고 클로저(핸들러)를 이용해 API를 사용하는 클라이언트가 특정 조건을 클로저로 작성해 값을 찾도록 만드는 방법이 있습니다.  

```swift
protocol CardSearchable {    
    func searchCard(handler: (Card) -> (Void))
}

class Deck: CardSearchable {
    private var cards = [Card]()

    //... 생략 
    func repeatCard(handler: (Card) -> (Void)) {
        cards.forEach { handler($0) }
    }
}

struct Card {    
    enum Suit: CaseIterable {
        case spade
        //... 생략 
    }
    
    enum Number: Int, CaseIterable {
        case ace = 1
        case two
        case three
        //... 생략 
    }
    //... 생략
}
```
=> `repeatCard` 메소드를 통해 클라이언트는 특정 조건을 클로저로 작성해 특정 값을 찾을 수 있습니다.

### 매개변수 목록은 짧게 유지하자.

매개변수 개수는 4개 이하가 좋습니다. 일단 4개가 넘어가면 매개변수를 전부 기억하기가 쉽지 않습니다. 우리가 만든 API에 이 제한을 넘는 메서드가 많다면 프로그래머들은 API 문서를 옆에 끼고 개발해야 할 것입니다.

**Swift는 인자 레이블이 있어서 매개변수끼리 구분이 되어 수고를 많이 덜 수 있지만**, 여전히 매개변수 수는 적은 쪽이 훨씬 낫습니다. 

**같은 타입의 매개변수 여러 개가 연달아 나오는 경우가 특히 해롭습니다.** 사용자가 매개변수 순서를 기억하기 어려울 뿐더러(Swift 경우에는 인자 레이블이 생략된 경우 똑같이 적용됩니다) 실수로 순서를 바꿔 입력해도 그대로 **컴파일되고 실행**됩니다. 단지 의도와 다르게 동작할 뿐입니다. 

## 과하게 긴 매개변수 목록을 짧게 줄여주는 기술 3가지

### 기술 1: 여러 메서드로 쪼갠다. 

Kingfisher 메소드 예시를 들자 

### 기술 2: 매개변수 여러 개를 묶어주는 클래스를 만든다. 

도우미 클래스 (rank suit)

### 기술 3: 객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용한다.


## 매개변수의 타입으로는 클래스보다는 프로토콜이 더 낫다. 

매개변수로 적합한 프로토콜이 있다면 (이를 구현한 클래스가 아닌) 그 프로토콜을 직접 사용합시다.
(프로토콜을 채택한)특정 클래스 대신 프로토콜 타입을 매개변수로 사용하면, 해당 프로토콜을 채택한 다른 어떤 클래스도 인수로 건넬 수 있기 때문입니다. **프로토콜 대신 클래스를 사용하면 클라이언트에게 특정 구현체만 사용하도록 제한하는 꼴이며, 혹시라도 입력 데이터가 다른 형태로 존재한다면 명시한 특정 구현체의 객체로 옮겨 담느라 비싼 복사 비용을 치러야 합니다.** 

```swift
protocol SomeProtocol {
    func describe()
}

func someFunction(someProtocol: SomeProtocol) {
    someProtocol.describe()
}
```
=> 이처럼 클래스보다는 프로토콜 타입으로 매개변수의 타입을 지정하십시오.

## boolean보다는 원소 2개짜리 열거 타입이 낫다(메서드 이름상 boolean을 받아야 의미가 더 명확할 때는 예외입니다).

열거 타입을 사용하면 코드를 읽고 쓰기가 쉬워집니다. 나중에 선택지를 추가하기도 쉽습니다. 
다음은 화씨온도(fahrenheit)와 섭씨온도(celsius)를 원소로 정의한 열거 타입입니다. 

```swift
enum TemperatureScale {
    case fahrenheit
    case celsius
}
```

온도계 클래스의 생성자가 이 열거 타입을 입력받아 적합한 온도계 인스턴스를 생성해준다고 해봅시다. 
`Thermomter(isFahrenheit: true)` 보다 `Thermometer(scale: .fahrenheit)`가 하는 일을 훨씬 명확히 알려줍니다. 나중에 캘빈온도도 지원해야 한다면, Thermometer에 새로운 생성자를 추가할 필요 없이 TemperatureScale 열거 타입에 캘빈온도(KELVIN)를 추가하면 됩니다. **또한, 온도 단위에 대한 의존성을 개별 열거 타입 상수의 메서드 안으로 리팩터링해 넣을 수도 있습니다(즉 상위 객체는 상위 객체대로, 하위 객체는 하위객체대로 SRP에 맞게 코드 작성할 수 있습니다)** 예컨대 double 값을 받아 섭씨온도로 변환해주는 메서드를 열거 타입 상수 각각에 정의해둘 수 있습니다. 

